
import { GoogleGenAI, SchemaType, GenerativeModel } from "@google/generative-ai";
import { saveDiagnosticResult } from "./databaseService";

// Helper to validate and get key
const getAPIKey = () => {
  const key = import.meta.env.VITE_API_KEY || ''; // Vite standard
  if (!key || key.includes('your_gemini_api_key')) {
    console.error("Gemini API Key is missing or invalid. Please check context.");
    throw new Error("Missing/Invalid API Key");
  }
  return key;
};

const getAI = () => new GoogleGenAI(getAPIKey());

const SYSTEM_INSTRUCTION = `You are MedGemma, a state-of-the-art clinical decision support AI. 
Follow these rules:
1. Use standard medical terminology (e.g., ICD-10 aligned).
2. Maintain a professional, objective tone.
3. Prioritize patient safety by flagging concerning findings immediately with âš ï¸.
4. Use Markdown for all text outputs. Structure reports with clear headers (# for H1, ## for H2, ### for H3), bullet points, and medical icons.
5. All outputs must include a footer disclaimer that this is for clinical decision support, not a primary diagnosis.
6. Use **bold** for clinical terms and *italic* for values.`;

export const analyzeRadiologyImage = async (base64Image: string, modality: string, bodyPart: string, patientId: string) => {
  const ai = getAI();
  const model = ai.getGenerativeModel({
    model: 'gemini-1.5-pro',
    systemInstruction: SYSTEM_INSTRUCTION,
    generationConfig: {
      responseMimeType: "application/json",
      responseSchema: {
        type: SchemaType.OBJECT,
        properties: {
          indication: { type: SchemaType.STRING },
          findings: { type: SchemaType.STRING },
          impression: { type: SchemaType.STRING },
          followUp: { type: SchemaType.STRING },
          tags: { type: SchemaType.ARRAY, items: { type: SchemaType.STRING } },
          layman_summary: { type: SchemaType.STRING }
        },
        required: ["indication", "findings", "impression", "followUp", "tags", "layman_summary"]
      }
    }
  });

  const prompt = `Perform a detailed radiological analysis of this ${modality} of the ${bodyPart}. 
  Provide structured findings and a definitive impression using Markdown headers and bullet points. Use ðŸ”¬ for findings and ðŸ©º for impressions.`;

  const response = await model.generateContent([
    prompt,
    { inlineData: { data: base64Image.split(',')[1], mimeType: 'image/png' } }
  ]);

  const text = response.response.text();
  const parsed = JSON.parse(text || '{}');

  // Persist to SurrealDB
  await saveDiagnosticResult('radiology', {
    patient: patientId,
    modality,
    body_part: bodyPart,
    report: parsed.findings + "\n" + parsed.impression,
    tags: parsed.tags,
    created_at: new Date()
  });

  return parsed;
};

export const performGlobalSearch = async (query: string, patientContext: any) => {
  const ai = getAI();
  const model = ai.getGenerativeModel({
    model: 'gemini-1.5-flash',
    systemInstruction: SYSTEM_INSTRUCTION
  });

  const prompt = `As MedGemma, synthesize a high-fidelity Clinical Synthesis Report for the query: "${query}".
  
  Format the report using strict Markdown:
  # ðŸ“‹ Clinical Synthesis Report: ${query}

  ## ðŸ©º Executive Summary
  Provide a professional summary of the patient status regarding this query. Use **bold** for key conclusions.

  ## ðŸ”¬ Clinical Evidence & Findings
  ### Diagnostic History
  - Detail specific findings from documents.
  - Use bullet points for clear delineation.
  - Reference specific modalities (XR, CT, etc.)

  ## âš ï¸ Risk Assessment & Safety Flags
  - Flag any abnormalities or contraindications.
  - Highlight critical values with âš ï¸.

  ## ðŸ“‹ Recommendations & Next Steps
  ### Action Items
  1. **Primary Action:** Immediate clinical directive.
  2. **Secondary Action:** Follow-up monitoring.

  ---
  > **Disclaimer:** This report is generated by MedGemma for clinical decision support. All findings must be validated by a licensed physician.

  Context: ${JSON.stringify(patientContext)}`;

  const response = await model.generateContent(prompt);
  return response.response.text();
};

export const queryClinicalDocs = async (docs: string[], query: string) => {
  const ai = getAI();
  const model = ai.getGenerativeModel({
    model: 'gemini-1.5-flash',
    systemInstruction: SYSTEM_INSTRUCTION
  });

  const prompt = `Based on the following clinical documents, provide a structured Markdown summary answering: "${query}"
  
  ---
  Documents:
  ${docs.map((d, i) => `[Doc ${i + 1}]: ${d}`).join('\n\n')}
  ---
  
  Structure with headers:
  # ðŸ“„ Document Review
  ## ðŸ’¡ Analysis
  ### ðŸ“ Conclusion`;

  const response = await model.generateContent(prompt);
  return response.response.text();
};

export const analyzeDermImage = async (base64Image: string, symptoms: string, duration: string, patientId: string) => {
  const ai = getAI();
  const model = ai.getGenerativeModel({
    model: 'gemini-1.5-pro',
    systemInstruction: SYSTEM_INSTRUCTION,
    generationConfig: {
      responseMimeType: "application/json",
      responseSchema: {
        type: SchemaType.OBJECT,
        properties: {
          assessment: { type: SchemaType.STRING },
          riskTier: { type: SchemaType.STRING },
          explanation: { type: SchemaType.STRING },
          nextSteps: { type: SchemaType.STRING },
          soapNote: { type: SchemaType.STRING }
        },
        required: ["assessment", "riskTier", "explanation", "nextSteps", "soapNote"]
      }
    }
  });

  const prompt = `Evaluate this dermatological lesion. Provide a structured SOAP note in Markdown using # for Subjective, Objective, Assessment, and Plan.`;

  const response = await model.generateContent([
    prompt,
    { inlineData: { data: base64Image.split(',')[1], mimeType: 'image/png' } }
  ]);

  const text = response.response.text();
  const parsed = JSON.parse(text || '{}');

  // Persist to SurrealDB
  await saveDiagnosticResult('dermatology', {
    patient: patientId,
    assessment: parsed.assessment,
    risk_tier: parsed.riskTier,
    soap_note: parsed.soapNote,
    created_at: new Date()
  });

  return parsed;
};
